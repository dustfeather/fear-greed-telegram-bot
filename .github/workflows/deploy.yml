name: Deploy to Cloudflare Workers
permissions:
  contents: read

on:
  push:
    branches: [ main ]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install Dependencies
        run: npm ci

      - name: Run Tests
        run: npm test
        continue-on-error: false

  validate:
    name: Validate (Type Check & Wrangler)
    runs-on: ubuntu-latest
    strategy:
      matrix:
        validation: [type-check, wrangler-validate]
      fail-fast: false
    timeout-minutes: 15

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install Dependencies
        run: npm ci

      - name: Generate wrangler.jsonc Configuration
        if: matrix.validation == 'wrangler-validate'
        shell: bash
        env:
          FEAR_GREED_KV_NAMESPACE_ID: ${{ secrets.FEAR_GREED_KV_NAMESPACE_ID }}
          FEAR_GREED_KV_PREVIEW_ID: ${{ secrets.FEAR_GREED_KV_PREVIEW_ID }}
        run: |
          set -euo pipefail
          
          # Generate wrangler.jsonc from environment variables using Node.js script
          node scripts/generate-wrangler-config.js
          
          # Verify the file was created and is not empty
          if [ ! -f wrangler.jsonc ] || [ ! -s wrangler.jsonc ]; then
            echo "❌ Error: wrangler.jsonc was not created or is empty"
            exit 1
          fi
          
          # Validate JSONC syntax
          if ! node -e "require('fs').readFileSync('wrangler.jsonc', 'utf8'); JSON.parse(require('fs').readFileSync('wrangler.jsonc', 'utf8').replace(/\/\/.*/g, ''));" > /dev/null 2>&1; then
            echo "❌ Error: wrangler.jsonc contains invalid JSON syntax"
            exit 1
          fi
          
          echo "Configuration preview (values redacted):"
          sed 's/"id":\s*"[^"]*"/"id": "***REDACTED***"/' wrangler.jsonc | sed 's/"preview_id":\s*"[^"]*"/"preview_id": "***REDACTED***"/' || true

      - name: Run TypeScript Type Check
        if: matrix.validation == 'type-check'
        run: npm run type-check
        continue-on-error: false

      - name: Validate wrangler.jsonc Configuration
        if: matrix.validation == 'wrangler-validate'
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CF_API_TOKEN }}
          accountId: ${{ secrets.CF_ACCOUNT_ID }}
          workingDirectory: .
          command: deploy --dry-run
        continue-on-error: false

      - name: Upload wrangler.jsonc artifact
        if: matrix.validation == 'wrangler-validate'
        uses: actions/upload-artifact@v4
        with:
          name: wrangler-config
          path: wrangler.jsonc
          retention-days: 1

  deploy:
    name: Deploy to Cloudflare Workers
    runs-on: ubuntu-latest
    needs: [test, validate]
    timeout-minutes: 60
    concurrency:
      group: deploy-${{ github.ref }}
      cancel-in-progress: false

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'npm'

      - name: Cache node_modules
        uses: actions/cache@v4
        with:
          path: node_modules
          key: ${{ runner.os }}-node-modules-${{ hashFiles('**/package-lock.json') }}
          restore-keys: |
            ${{ runner.os }}-node-modules-

      - name: Install Dependencies
        run: npm ci

      - name: Download wrangler.jsonc artifact
        uses: actions/download-artifact@v4
        with:
          name: wrangler-config
          path: .
        continue-on-error: true

      - name: Generate wrangler.jsonc Configuration
        shell: bash
        env:
          FEAR_GREED_KV_NAMESPACE_ID: ${{ secrets.FEAR_GREED_KV_NAMESPACE_ID }}
          FEAR_GREED_KV_PREVIEW_ID: ${{ secrets.FEAR_GREED_KV_PREVIEW_ID }}
        run: |
          set -euo pipefail
          
          # Check if wrangler.jsonc already exists from artifact download
          if [ -f wrangler.jsonc ] && [ -s wrangler.jsonc ]; then
            echo "✓ Using wrangler.jsonc from artifact"
            # Validate JSONC syntax
            if ! node -e "require('fs').readFileSync('wrangler.jsonc', 'utf8'); JSON.parse(require('fs').readFileSync('wrangler.jsonc', 'utf8').replace(/\/\/.*/g, ''));" > /dev/null 2>&1; then
              echo "⚠️  Warning: Downloaded wrangler.jsonc contains invalid JSON syntax, regenerating..."
            else
              echo "Configuration preview (values redacted):"
              sed 's/"id":\s*"[^"]*"/"id": "***REDACTED***"/' wrangler.jsonc | sed 's/"preview_id":\s*"[^"]*"/"preview_id": "***REDACTED***"/' || true
              exit 0
            fi
          fi
          
          # Generate wrangler.jsonc from environment variables using Node.js script
          echo "Generating wrangler.jsonc..."
          node scripts/generate-wrangler-config.js
          
          # Verify the file was created and is not empty
          if [ ! -f wrangler.jsonc ] || [ ! -s wrangler.jsonc ]; then
            echo "❌ Error: wrangler.jsonc was not created or is empty"
            exit 1
          fi
          
          # Validate JSONC syntax
          if ! node -e "require('fs').readFileSync('wrangler.jsonc', 'utf8'); JSON.parse(require('fs').readFileSync('wrangler.jsonc', 'utf8').replace(/\/\/.*/g, ''));" > /dev/null 2>&1; then
            echo "❌ Error: wrangler.jsonc contains invalid JSON syntax"
            exit 1
          fi
          
          echo "Configuration preview (values redacted):"
          sed 's/"id":\s*"[^"]*"/"id": "***REDACTED***"/' wrangler.jsonc | sed 's/"preview_id":\s*"[^"]*"/"preview_id": "***REDACTED***"/' || true

      - name: Set Cloudflare Secrets
        shell: bash
        env:
          TELEGRAM_BOT_TOKEN_SECRET: ${{ secrets.TELEGRAM_BOT_TOKEN_SECRET }}
          TELEGRAM_WEBHOOK_SECRET: ${{ secrets.TELEGRAM_WEBHOOK_SECRET }}
          ADMIN_CHAT_ID: ${{ secrets.ADMIN_CHAT_ID }}
          CLOUDFLARE_API_TOKEN: ${{ secrets.CF_API_TOKEN }}
          CLOUDFLARE_ACCOUNT_ID: ${{ secrets.CF_ACCOUNT_ID }}
        run: |
          set -euo pipefail
          
          # Validate required secrets are not empty
          REQUIRED_SECRETS=(
            "TELEGRAM_BOT_TOKEN_SECRET"
            "TELEGRAM_WEBHOOK_SECRET"
            "ADMIN_CHAT_ID"
            "CLOUDFLARE_API_TOKEN"
            "CLOUDFLARE_ACCOUNT_ID"
          )
          
          MISSING_SECRETS=()
          for secret in "${REQUIRED_SECRETS[@]}"; do
            if [ -z "${!secret:-}" ]; then
              MISSING_SECRETS+=("$secret")
            fi
          done
          
          if [ ${#MISSING_SECRETS[@]} -ne 0 ]; then
            echo "❌ Error: Missing or empty required secrets:"
            printf '  - %s\n' "${MISSING_SECRETS[@]}"
            exit 1
          fi
          
          echo "✓ All required secrets are present"
          
          # Validate wrangler.jsonc exists
          if [ ! -f "wrangler.jsonc" ]; then
            echo "❌ Error: wrangler.jsonc not found. Make sure it was generated in the previous step."
            exit 1
          fi
          
          # Create temporary JSON file with secrets
          SECRETS_FILE=$(mktemp)
          trap "rm -f '$SECRETS_FILE'" EXIT
          
          # Validate file was created successfully
          if [ ! -f "$SECRETS_FILE" ]; then
            echo "❌ Error: Failed to create temporary secrets file"
            exit 1
          fi
          
          # Write JSON file with proper escaping using Node.js
          node -e "
            const fs = require('fs');
            const secrets = {
              TELEGRAM_BOT_TOKEN_SECRET: process.env.TELEGRAM_BOT_TOKEN_SECRET,
              TELEGRAM_WEBHOOK_SECRET: process.env.TELEGRAM_WEBHOOK_SECRET,
              ADMIN_CHAT_ID: process.env.ADMIN_CHAT_ID
            };
            fs.writeFileSync('$SECRETS_FILE', JSON.stringify(secrets, null, 2));
          "
          
          # Verify JSON file is valid and not empty
          if [ ! -s "$SECRETS_FILE" ]; then
            echo "❌ Error: Secrets file is empty"
            exit 1
          fi
          
          # Verify JSON is valid
          if ! node -e "require('fs').readFileSync('$SECRETS_FILE', 'utf8'); JSON.parse(require('fs').readFileSync('$SECRETS_FILE', 'utf8'));" > /dev/null 2>&1; then
            echo "❌ Error: Secrets file contains invalid JSON"
            exit 1
          fi
          
          # Upload secrets using wrangler secret bulk
          # wrangler reads CLOUDFLARE_API_TOKEN and CLOUDFLARE_ACCOUNT_ID from env
          echo "Setting Cloudflare secrets..."
          echo "Worker name from wrangler.jsonc:"
          node -e "try { const config = JSON.parse(require('fs').readFileSync('wrangler.jsonc', 'utf8').replace(/\/\/.*/g, '')); console.log(config.name || 'Not found'); } catch(e) { console.log('Warning: Could not find worker name in wrangler.jsonc'); }" || echo "Warning: Could not find worker name in wrangler.jsonc"
          
          # Use filename directly instead of stdin redirection for better compatibility
          # With set -e, the script will exit if this command fails
          npx wrangler secret bulk "$SECRETS_FILE"
          
          echo "✓ Secrets uploaded successfully"

      - name: Deploy to Cloudflare Workers
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CF_API_TOKEN }}
          accountId: ${{ secrets.CF_ACCOUNT_ID }}
          workingDirectory: .
        continue-on-error: false

  post-deploy:
    name: Post-Deployment Tasks
    runs-on: ubuntu-latest
    needs: deploy
    strategy:
      matrix:
        task: [webhook, notify]
      fail-fast: false
    timeout-minutes: 5

    steps:
      - name: Checkout Repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Set Telegram Webhook
        if: matrix.task == 'webhook'
        shell: bash
        env:
          TELEGRAM_BOT_TOKEN_SECRET: ${{ secrets.TELEGRAM_BOT_TOKEN_SECRET }}
          TELEGRAM_WEBHOOK_SECRET: ${{ secrets.TELEGRAM_WEBHOOK_SECRET }}
          WEBHOOK_URL: ${{ secrets.WORKER_URL }}
        run: |
          set -euo pipefail
          
          # Set webhook after deployment
          # Note: This is idempotent - safe to run on every deployment
          if [ -z "${TELEGRAM_BOT_TOKEN_SECRET:-}" ]; then
            echo "⚠️  Warning: TELEGRAM_BOT_TOKEN_SECRET not set, skipping webhook setup"
            exit 0
          fi
          
          if [ -z "${TELEGRAM_WEBHOOK_SECRET:-}" ]; then
            echo "⚠️  Warning: TELEGRAM_WEBHOOK_SECRET not set, skipping webhook setup"
            exit 0
          fi
          
          if [ -z "${WEBHOOK_URL:-}" ]; then
            echo "⚠️  Warning: WORKER_URL secret not set, skipping webhook setup"
            exit 0
          fi
          
          node scripts/setup-telegram-webhook.js "${WEBHOOK_URL}"
          
          echo "✓ Telegram webhook configured successfully"

      - name: Notify Subscribers of Deployment
        if: matrix.task == 'notify'
        shell: bash
        env:
          TELEGRAM_BOT_TOKEN_SECRET: ${{ secrets.TELEGRAM_BOT_TOKEN_SECRET }}
          WORKER_URL: ${{ secrets.WORKER_URL }}
          GITHUB_SHA: ${{ github.sha }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          GITHUB_EVENT_HEAD_COMMIT_MESSAGE: ${{ github.event.head_commit.message }}
        run: |
          set +e
          
          # Skip if required secrets are not set
          if [ -z "${TELEGRAM_BOT_TOKEN_SECRET:-}" ]; then
            echo "⚠️  Warning: TELEGRAM_BOT_TOKEN_SECRET not set, skipping deployment notification"
            exit 0
          fi
          
          if [ -z "${WORKER_URL:-}" ]; then
            echo "⚠️  Warning: WORKER_URL secret not set, skipping deployment notification"
            exit 0
          fi
          
          # Extract short commit hash (7 characters)
          COMMIT_HASH="${GITHUB_SHA:0:7}"
          
          # Construct GitHub commit URL
          COMMIT_URL="https://github.com/${GITHUB_REPOSITORY}/commit/${GITHUB_SHA}"
          
          # Get commit message (prefer head_commit.message, fallback to 'Deployment')
          if [ -n "${GITHUB_EVENT_HEAD_COMMIT_MESSAGE:-}" ]; then
            COMMIT_MSG="${GITHUB_EVENT_HEAD_COMMIT_MESSAGE}"
          else
            COMMIT_MSG="Deployment"
          fi
          
          # Get first line of commit message (remove newlines and trim)
          COMMIT_MSG=$(echo "${COMMIT_MSG}" | head -n1 | tr '\n' ' ' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
          
          # Send deployment notification
          echo "Sending deployment notification..."
          echo "Commit: ${COMMIT_HASH}"
          echo "Message: ${COMMIT_MSG}"
          echo "URL: ${COMMIT_URL}"
          
          RESPONSE=$(curl -s -w "\n%{http_code}" -X POST "${WORKER_URL}/deploy-notify" \
            -H "Content-Type: application/json" \
            -H "Authorization: Bearer ${TELEGRAM_BOT_TOKEN_SECRET}" \
            -d "{
              \"commitHash\": \"${COMMIT_HASH}\",
              \"commitMessage\": \"${COMMIT_MSG}\",
              \"commitUrl\": \"${COMMIT_URL}\",
              \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\"
            }")
          
          HTTP_CODE=$(echo "${RESPONSE}" | tail -n1)
          BODY=$(echo "${RESPONSE}" | sed '$d')
          
          if [ "${HTTP_CODE}" -eq 200 ]; then
            echo "✓ Deployment notification sent successfully"
            echo "Response: ${BODY}"
          else
            echo "⚠️  Warning: Deployment notification failed (HTTP ${HTTP_CODE})"
            echo "Response: ${BODY}"
          fi
        continue-on-error: true

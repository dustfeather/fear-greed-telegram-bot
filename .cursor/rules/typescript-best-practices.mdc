---
description: Enforce TypeScript best practices and modern coding standards
globs: ["**/*.ts", "**/*.tsx"]
alwaysApply: false
---

# TypeScript Best Practices

## Strict Type Configuration

**Enable strict mode with all safety flags in tsconfig.json:**
- Set `"strict": true`
- Enable `"noImplicitAny": true`
- Enable `"strictNullChecks": true`
- Enable `"strictFunctionTypes": true`
- Enable `"strictBindCallApply": true`
- Enable `"strictPropertyInitialization": true`
- Enable `"noUncheckedIndexedAccess": true`
- Enable `"exactOptionalPropertyTypes": true`

**Never use `any` type - use proper alternatives:**
- Use `unknown` for truly unknown types and narrow with type guards
- Use specific union types for known variants
- Use generics with constraints for reusable type-safe code
- Prefer interfaces or type aliases over implicit typing

## Type Safety Patterns

**Explicit type definitions:**
- Always specify return types on functions for clarity and contract enforcement
- Use explicit parameter types instead of relying solely on inference
- Define interfaces for object shapes
- Use type aliases for unions, intersections, and complex types

**Type narrowing and guards:**
- Use `instanceof` checks for class instances
- Use `typeof` checks for primitives
- Create custom type guard functions with `is` predicates
- Handle `unknown` types safely with type guards before accessing properties
- Use discriminated unions with exhaustiveness checking

**Utility types:**
- Leverage `Partial<T>`, `Required<T>`, `Pick<T, K>`, `Omit<T, K>`, `Record<K, V>`
- Use `Readonly<T>` for immutable object types
- Use `ReadonlyArray<T>` or `readonly T[]` for immutable arrays
- Create custom mapped types and conditional types to reduce duplication

## Immutability Practices

**Prefer immutable data structures:**
- Use `readonly` modifier on properties that shouldn't change
- Use `Readonly<T>` utility type for entire objects
- Use `ReadonlyArray<T>` or `readonly T[]` for arrays
- Use `as const` assertions for literal types
- Avoid mutating function parameters

**Deep immutability when needed:**
```typescript
type DeepReadonly<T> = {
  readonly [K in keyof T]: T[K] extends object 
    ? DeepReadonly<T[K]> 
    : T[K];
};
```

## Function Best Practices

**Function definitions:**
- Always specify explicit return types
- Use type aliases for reusable function signatures
- Prefer arrow functions for callbacks and simple expressions
- Use function declarations for named functions with hoisting needs

**Parameters:**
- Use optional parameters (`param?`) sparingly with clear defaults
- Use default parameters to simplify function calls
- Use rest parameters (`...args: T[]`) for variable arguments
- Name parameters descriptively

**Function overloads:**
- Ensure overload signatures produce consistent return types
- Always implement a single function body that handles all overloads
- Document edge cases and behavior differences

## Error Handling

**Modern error handling patterns:**
- Use try-catch blocks for synchronous error handling
- Treat caught errors as `unknown` type and narrow before use
- Create custom error classes extending `Error` for domain-specific errors
- Include meaningful error messages and context
- Use error codes or types for programmatic error handling

**Type-safe error handling:**
```typescript
function isCustomError(error: unknown): error is CustomError {
  return error instanceof CustomError && typeof error.code === 'string';
}

try {
  // risky operation
} catch (error: unknown) {
  if (isCustomError(error)) {
    console.error(error.code, error.message);
  } else if (error instanceof Error) {
    console.error(error.message);
  } else {
    console.error('Unknown error occurred');
  }
}
```

**Async error handling:**
- Use try-catch with async/await for Promise-based code
- Handle promise rejections with `.catch()` when using promise chains
- Always return or throw errors to maintain error flow
- Use `Promise.allSettled()` for parallel operations that shouldn't fail together

## Naming Conventions

**Case conventions:**
- `PascalCase` for interfaces, types, classes, enums
- `camelCase` for variables, functions, methods, parameters
- `UPPER_SNAKE_CASE` for global constants and enum values
- `kebab-case` for file names

**Descriptive naming:**
- Use clear, descriptive names without unnecessary abbreviations
- Use auxiliary verbs for boolean variables (`isLoading`, `hasError`, `canEdit`)
- Prefix type parameters with descriptive names (e.g., `TUser`, `TResponse`)
- Avoid single-letter type parameters except for simple generics

**Prefixes and conventions:**
- Do NOT prefix interfaces with `I` (use `User`, not `IUser`)
- Do NOT prefix types with `T` (use `UserType`, not `TUserType`)
- Use suffixes like `Props`, `Config`, `Options` for configuration types

## Code Organization

**Project structure:**
- Place source files in `src/` directory
- Organize by feature or domain, not by file type
- Keep related files together (component, types, tests, styles)
- Use barrel exports (`index.ts`) to simplify imports
- Place compiled output in `dist/` or `build/` directory

**Module organization:**
- Create clear module boundaries with explicit exports
- Avoid circular dependencies
- Use path aliases in `tsconfig.json` for cleaner imports
- Group imports: external libraries, internal modules, types, styles

**File structure best practices:**
- One primary export per file when possible
- Co-locate type definitions with their usage
- Create separate `types.ts` files for shared types
- Keep files focused and under 300 lines when practical

## Code Quality Standards

**Modern TypeScript patterns:**
- Use `const` for all variables that aren't reassigned
- Prefer object/array destructuring
- Use template literals over string concatenation
- Use optional chaining (`?.`) and nullish coalescing (`??`)
- Avoid unnecessary type assertions (`as`, `!`)

**Avoid anti-patterns:**
- Never use `@ts-ignore` without explanation and TODO
- Never use `@ts-expect-error` as a permanent solution
- Avoid type assertions that hide real type issues
- Don't use `Function` type - use specific function signatures
- Avoid implicit `any` on function parameters

**Generics best practices:**
- Add constraints to type parameters when appropriate
- Use descriptive names for complex generics
- Let TypeScript infer generic types when possible
- Don't over-engineer with unnecessary generic abstraction

## Documentation and Comments

**Type documentation:**
- Document complex types with JSDoc comments
- Explain non-obvious type constraints or behaviors
- Use `@example` tags for complex type usage
- Document public API boundaries thoroughly

**Code comments:**
- Explain "why" not "what" in comments
- Document edge cases and assumptions
- Keep comments up-to-date with code changes
- Use TODO comments with issue tracking references

## Testing Considerations

**Type-safe testing:**
- Use proper types for test fixtures and mocks
- Avoid `any` in test code
- Create type-safe test utilities
- Test type narrowing and error handling paths

## Performance and Build

**Build optimization:**
- Use `skipLibCheck: true` to speed up compilation
- Configure appropriate `target` and `lib` options
- Use project references for large codebases
- Enable incremental compilation for faster rebuilds

**Runtime considerations:**
- TypeScript types are compile-time only
- Use runtime validation (Zod, Yup) for external data
- Be aware of type erasure in compiled JavaScript
- Profile and optimize hot paths in production code

## Linting and Formatting

**Use ESLint with TypeScript:**
- Install `@typescript-eslint/parser` and `@typescript-eslint/eslint-plugin`
- Enable recommended TypeScript rules
- Configure naming conventions with `@typescript-eslint/naming-convention`
- Use Prettier for consistent formatting

**Key ESLint rules to enable:**
- `@typescript-eslint/no-explicit-any`
- `@typescript-eslint/explicit-function-return-type`
- `@typescript-eslint/no-unused-vars`
- `@typescript-eslint/strict-boolean-expressions`
